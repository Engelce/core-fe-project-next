## Overview

core-fe is a frontend framework based on react, redux, react-saga, it's designed to support our own projects.

[![Build Status](https://github.com/neowu/core-fe-project/workflows/build/badge.svg)](https://github.com/neowu/core-fe-project/actions)
[![Language grade: JavaScript](https://img.shields.io/lgtm/grade/javascript/g/neowu/core-fe-project.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/neowu/core-fe-project/context:javascript)

## Local Dev

This project uses [pnpm](https://pnpm.io/) to manage the dependencies.

- To install the dependencies, run `pnpm install`
- To run the build script, run `pnpm build`
- To publish to npm, run `pnpm publish`, which runs `pnpm build` automatically before publish

## Basic Features

The whole website is split into **modules**, usually by routes.

For each module, it contains **1 state** and **some actions**, to handle business logic.

To extend module features, modules can also implement its own lifecycle actions, like onEnter/onDestroy/onActive etc.

## Advanced Features

- global error-handler

- event collector

- action decorator

## Core API

- bootstrap

Bootstrap function, configuring entry component / error handler / log / initialization action.

- register

Register a module (including lifecycle actions and custom actions).

For more detailed instructions, please go to the `examples` folder.

## Migrating to v2
In v2, we made some changes, removing redux, redux-saga, generate syntax, etc. and replacing them with new libraries such as zustand.

- replace

In the Module, since we ditched redux-saga, we can use normal async, await syntax to handle business scenarios.

    - before
```
class MainModule extends Module<RootState, "main"> {
    *fetchList(): SagaGenerator {
        const response = yield* call(ListService.list);
        this.setState({
            list: response.list
        })
    }
    *onEnter() {
        yield* this.fetchList();
    }
}
```
    - after 
```
class MainModule extends Module<RootState, "main"> {
    async fetchList() {
        const response = await ListService.list();
        this.setState({
            list: response.list
        })
    }
    onEnter() {
        this.fetchList();
    }
}
```
When using an action, you can call the function on the action directly without using a hook or dispatch.

    - before
```
import {actions} from "..";
import {useAction} from "@wonder/core-fe"

function Example() {
    const fetchList = useAction(actions.fetchList);

    return (
        <button onClick={fetchList}>Fetch List</button>
    );
}
```
    - after
```
import {actions} from "..";

function Example() {
    return (
        <button onClick={actions.fetchList}>Fetch List</button>
    );
}
```

- removed

In before, core-fe will cancel some asynchrony being executed in the current module when onDestroy, onPathnameMatched/onLocationMatched is triggered repeatedly, and this can't be done in the new version, so you need to control the asynchrony within the module by yourself if there is a need for this scenario if you have a need for it.

- added

For these reasons, core-fe provides built-in asynchronous handlers for on-demand calls (built-in `executeAsync` function in module)
After wrapping asynchronous with this method, the abortcontroller will be mounted on `app.actionControllers`, and you can get the controller by `app.actionControllers[moduleName][key]` and decide whether to cancel the current action or not.
In the module, also added `abortControllerMap` attribute, you can directly get the current module under the mount of all controllermap.
In lifecycle `onDestroy`, asynchronous (unfinished) processing with executeAsync is uniformly canceled under the current module.
`executeAsync` If the `key` is duplicated in the same module, the new controller will replace the old one.
```
// async executeAsync<T extends any>(asyncFn: (signal: AbortSignal) => Promise<T>, key?: string)
// If the second parameter `key` is not passed, a uid will be generated by default.

class TemplateModule extends Module<RootState, "Template"> {
    override async onEnter(entryComponentProps: any) {
        await this.getTodoList();
    }
    cancelGetTodoList() {
        this.abortControllerMap["getTodoList"]?.abort()
    }
    async getTodoList() {
        const list = await this.executeAsync((signal: AbortSignal) => MockData.todoList(signal), "getTodoList")
        this.setList({list})
    }
}
```